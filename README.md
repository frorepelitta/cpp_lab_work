Захаров ИТ5 Вариант 2

1.3 Дан набор целых чисел с четным количеством элементов. Заполнить вектор V исходными
числами, вывести вначале вторую половину элементов вектора V, а затем первую половину (в
каждой половине порядок элементов не изменять).
Для удобства, я заполню вектор из обычного массива. Далее просто создам два указателя, один направлен на середину - v.begin + v.size()/2 , а второй на начало.
Затем выведу элементы указателя от середины, а затем от начала до середины.
ТЕСТ
Ввод - V = {1, 2, 3, 4}\
Вывод -\
1 2\
3 4


2.4 Даны вектор V и список L. Каждый исходный контейнер содержит не менее 5 элементов.
Вставить после элемента списка с порядковым номером 5 первые 5 элементов вектора в
обратном порядке. Использовать один вызов функции-члена insert.
Тут создаю обратный итератор rbegin и направляю его на 5 элемент контейнера iter + (v.size() - 5). Далее при помощи insert и стандартного итератора добавляю после 5 элемента первые 5 элементов вектора в список.
ТЕСТ
Ввод - V = {1, 2, 3, 4, 5}, L = [1, 2, 3, 4, 5]\
Вывод - 1 2 3 4 5 5 4 3 2 1


3.7 Даны списки L1 и L2, имеющие четное количество элементов. Поменять местами первую
половину исходного списка L1 и вторую половину исходного списка L2. Использовать два
вызова функции-члена splice.
Тут я по очереди меняю местами половины списков, сначала я вторую половину второго списка добавляю в начало первого при помощи splice и далее первую половину первого в конец второго тоже при помощи splice.
ТЕСТ
Ввод - L1 = [1, 2, 3, 4], L2 = [5, 6, 7, 8]
Вывод - 
7 8 3 4
5 6 1 2


4.1 Дано целое число K (> 0), текстовый файл с именем name1, содержащий английские слова, и
строка name2. Записать в текстовый файл с именем name2 все слова из исходного файла, длина
которых не превосходит K, сохранив исходный порядок их следования и располагая каждое
слово на новой строке. Использовать алгоритм remove_copy_if.
Эта задача решается за один алгоритм remove_copy_if - открываем один итератор на чтение с файла name1 и один на запись в name2 , далее задаем лямбда функцию которая проверяет длину слов, и алгоритм сам запишет в файл name2 слова нужной длины.
ТЕСТ - есть предзаписанный файл со словами на английском, при введеном K создается файл name2 в котором все слова из name1 длины < K. 


5.2 Дан дек D. Удалить последний нулевой элемент дека. Если нулевых элементов нет, то дек не
изменять. Использовать алгоритм find с обратными итераторами и функцию-член erase.
Указание. Алгоритм find может возвращать обратный итератор, однако функция-член erase не
позволяет его использовать для удаления элемента. Необходимо перейти от обратного
итератора r к связанному с ним обычному итератору, используя функцию-член обратного
итератора r.base(). При этом следует учитывать, что функция r.base() возвращает итератор,
связанный с элементом, следующим за тем, с которым связан обратный итератор r. Поэтому в
функции-члене erase следует указать одно из следующих выражений (предполагается, что r —
это обратный итератор, который вернул алгоритм find, и этот итератор отличен от rend): --
r.base() или (++r).base().
Запускаем алгоритм find при заданых начале - rbegin и конце rend, так они пойдут справа налево по контейнеру и будут искать 0, когда 0 найден мы удаляем при помощи erase, но перед этим надо нормализовать указатель на элемент который казывает на 0, т.к erase на работает с обратными указателями.
ТЕСТ
Ввод - D = {1, 2, 0, 3, 4}
Вывод - 
Последний ноль успешно удален
1 2 3 4


8.1 Дан список L. Получить вектор V вещественных чисел, содержащий значения среднего
арифметического для всех пар соседних элементов исходного списка (количество элементов
вектора V должно быть на 1 меньше количества элементов списка L). Например, для исходного
списка 1, 3, 4, 6 полученный вектор должен содержать значения 2.0, 3.5, 5.0. Использовать
алгоритм adjacent_difference с итератором вставки и функциональным объектом, а также
функцию-член erase для вектора V
Тут мы создаем структуру для вычисления среднего двух чисел, и используем алгоритм, в которы кладем список L, итератор вставки, и функциональный обьект который будет считать среднее, после выполнения алгоритма мы удаляем первый элемент и выводим получившиеся числа.
ТЕСТ 
Ввод - L = [1, 2, 3, 4, 5]
Вывод - 1.5 2.5 3.5 4.5


9.1 Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0
не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N,
в которых содержатся все элементы вектора V0 (без учета их повторений). Использовать
алгоритм includes, применяя его в цикле к двум множествам, одно из которых создано на основе
вектора V0, а другое на очередной итерации содержит элементы очередного из векторов VI, I = 1, …, N.
Создаю N векторов со случайным содержимым длины от 5 до 10, далее просто в цикле фор делаю каждый вектор множеством, чтобы убрать повторения, потом при помощи includes задаю указатели на начало и конец вектора V0 и на начало и конец вектора VN, затем если includes возвращает True, то добавляю еденицу в переменную для подсчета количества совпадающих векторов.
ТЕСТ 
Ввод - V0 = {1, 2, 3, 4,5}, N = 5
Вывод - программа создает N векторов случайно длины от 5 до 10 и выводит число векторов с полностью совпадающими элементами из V0


10.2 Дан вектор V, элементами которого являются английские слова, набранные заглавными
буквами. Определить суммарную длину слов, начинающихся с одной и той же буквы, и вывести
все различные буквы, с которых начинаются элементы вектора V, вместе с суммарной длиной
этих элементов (в алфавитном порядке букв); длину выводить сразу после соответствующей
буквы. Использовать вспомогательное отображение M, ключами которого являются начальные
буквы элементов вектора V, а значениями — суммарная длина этих элементов. При заполнении
отображения M не использовать условные конструкции (достаточно операций индексирования
[], инкремента и функции-члена size для строк). Элементы вектора V (при заполнении
отображения M) и элементы отображения M (при выводе полученных результатов) перебирать
в цикле с параметром-итератором соответствующего контейнера.
Здесь мы заполняем map где ключ это буква а значение это сумма букв в словах. В map сортировка происходит автоматически. 
ТЕСТ
Ввод - ALPHABET APPLE ARISE GREEN RISE
Вывод - 
A18
G5
R4
